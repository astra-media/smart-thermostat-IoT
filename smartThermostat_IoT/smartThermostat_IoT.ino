#include "arduino_secrets.h"
/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/dcedce49-dae5-4953-9a9f-c43fedffbba1 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  CloudDimmedLight blinds;
  CloudSwitch airCon;
  CloudSwitch fan;
  CloudTemperatureSensor temperature;
  CloudTemperatureSensor thermostat;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/


#include "thingProperties.h"
#include "DHT.h"

#include <Arduino.h>
#include <IRremoteESP8266.h>
#include <IRsend.h>

const uint16_t kIrLed = 4;  // ESP8266 GPIO pin to use. Recommended: 4 (D2).
IRsend irsend(kIrLed);  // Set the GPIO to be used to sending the message.

/*
 The circuit:
 * LCD RS pin to digital pin 12 myEdit: 18
 * LCD Enable pin to digital pin 11 myEdit: 19
 * LCD D4 pin to digital pin 5  myEdit: 21
 * LCD D5 pin to digital pin 4  myEdit: 22
 * LCD D6 pin to digital pin 3  myEdit: 23
 * LCD D7 pin to digital pin 2  myEdit: 25
 * LCD R/W pin to ground
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)
*/
#include <LiquidCrystal.h>
const int rs = 18, en = 19, d4 = 21, d5 = 22, d6 = 23, d7 = 25;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

#define DHTPIN 32     // Digital pin connected to the DHT sensor
#define DHTTYPE DHT11 
DHT dht(DHTPIN, DHTTYPE);

#define TEMP_UP_PIN 16  // the number of the TEMP_UP_PIN
#define TEMP_DOWN_PIN 17
#define AIRCON_SWITCH_PIN 34
#define PHOTORESISTOR_PIN 36

#define LED_PIN 2

bool airConSwitch = false;

int setTemp = 0;

int getTemp = 60;

bool airConState = false;

int airConOnValue = 1900;

TaskHandle_t Task1; //task1 is going to be used for the core 1


void setup() {
  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

    // Initialize serial and wait for port to open:
  Serial.begin(115200);
  //set the resolution to 12 bits (0-4096)
  analogReadResolution(12);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 

  // initialize the pushbutton pin as an input:
  pinMode(TEMP_UP_PIN, INPUT);
  pinMode(TEMP_DOWN_PIN, INPUT);
  pinMode(AIRCON_SWITCH_PIN, INPUT);
  pinMode(LED_PIN, OUTPUT);

  dht.begin();

  irsend.begin();

  lcd.begin(16, 2);
  
  setTemp = 82;

  /*create a task that will be executed in the Task1code() function, with priority 1 and executed on core 1
  (Priority values start at 0, in which 0 is the lowest priority. The processor will run the tasks with higher priority first)
  */

  xTaskCreatePinnedToCore(
                  Task1code,   /* Task function. */
                  "Task1",     /* name of task. */
                  10000,       /* Stack size of task */
                  NULL,        /* parameter of the task */
                  1,           /* priority of the task */
                  &Task1,      /* Task handle to keep track of created task */
                  1);          /* pin task to core 0 */                  
  delay(500);
}

//Task1code:
void Task1code( void * pvParameters ){
  Serial.print("Task1 running on core ");
  Serial.println(xPortGetCoreID());

  //The for(;;) creates an infinite loop. So, this function runs similarly to the loop() function. You can use it as a second loop in your code
  for(;;){
    temperature = getTemp;
    getTempfromDHT();
    getAirConState();
    controlAirCon();
  } 
}

//Arduino sketches run on core 1 by default. So, you could write the code for Task2 in the loop() (there is no need to create another task)
void loop() {
  ArduinoCloud.update();
  // Your code here 
  setAirCon();
  setLCD();
}

/*
  Since AirCon is READ_WRITE variable, onAirConChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onAirConChange()  {
  // Add your code here to act upon AirCon change
    if(airCon){
      airConSwitch = true;
    } else if (!airCon){
      airConSwitch = false;
    }
  Serial.println(airCon);

  
}

/*
  Since Thermostat is READ_WRITE variable, onThermostatChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onThermostatChange()  {
  // Add your code here to act upon Thermostat change
  if(thermostat <= 68){
    setTemp = 68;
  } else if (thermostat >= 104){
    setTemp = 104;
  } else {
    setTemp = int(thermostat);
  }
  Serial.println(thermostat);

}


/*
  Since Blinds is READ_WRITE variable, onBlindsChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onBlindsChange()  {
  // Add your code here to act upon Blinds change
    int blindPosition = int(blinds.getBrightness() +1);
    // Serial.println(blindPosition);
    Serial.println("Sending IR");

    if(blindPosition < 25){
      Serial.println(blindPosition);
      Serial.println("Fully closing blinds");
      irsend.sendNEC(0xFF6897);
      delay(200);
      irsend.sendNEC(0xFF6897);
      delay(200);
      irsend.sendNEC(0xFF6897);
      return;
    }

    if(blindPosition >= 25 && blindPosition < 50){
      Serial.println(blindPosition);
      Serial.println("Closing blinds");
      irsend.sendNEC(0xFF30CF);
      delay(200);
      irsend.sendNEC(0xFF30CF);
      delay(200);
      irsend.sendNEC(0xFF30CF);
      return;
    }

    if(blindPosition >= 50 && blindPosition < 75){
      Serial.println(blindPosition);
      Serial.println("Opening blinds");
      irsend.sendNEC(0xFF18E7);
      delay(200);
      irsend.sendNEC(0xFF18E7);
      delay(200);
      irsend.sendNEC(0xFF18E7);
      return;
    }

    if(blindPosition >= 75){
      Serial.println(blindPosition);
      Serial.println("Fully opening blinds");
      irsend.sendNEC(0xFF7A85);
      delay(200);
      irsend.sendNEC(0xFF7A85);
      delay(200);
      irsend.sendNEC(0xFF7A85);
      return;
    }
}

/*
  Since Fan is READ_WRITE variable, onFanChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onFanChange()  {
  // Add your code here to act upon Fan change
  if (fan){
    Serial.println("Fan On");
      Serial.println("Sending IR");
      irsend.sendNEC(0xFFA25D);
      delay(200);
      irsend.sendNEC(0xFFA25D);
      delay(200);
      irsend.sendNEC(0xFFA25D);
  } else if (!fan){
    Serial.println("Fan Off");
    Serial.println("Sending IR");
    irsend.sendNEC(0xFFE21D);
    delay(200);
    irsend.sendNEC(0xFFE21D);
    delay(200);
    irsend.sendNEC(0xFFE21D);
  }
}


/* AirCon Functions */

void controlAirCon () {
    if(airConSwitch){
      if(getTemp >= setTemp){
        if (!airConState){
          float validatedTemp = validateTempfromDHT();                
          if(validatedTemp >= setTemp && validatedTemp != 0){
            digitalWrite(LED_PIN, HIGH);
            Serial.println("Turning On AC");
            irsend.sendNEC(0x4FB40BF);
            delay(3000); 
          }
        }
      } else if (getTemp < (setTemp - 2)){
        if(airConState) {    
          float validatedTemp = validateTempfromDHT();                
          if(validatedTemp < (setTemp - 2) && validatedTemp != 0){
            digitalWrite(LED_PIN, LOW);
            Serial.println("Turning Off AC");
            irsend.sendNEC(0x4FB40BF);
            delay(3000); 
          }
        }
      }
    } else {
      if(airConState) {
        if(validateAirConState()){
          digitalWrite(LED_PIN, LOW);
          Serial.println("Turning Off AC");
          irsend.sendNEC(0x4FB40BF);
          delay(3000); 
        }
        }
    }
  }


void setAirCon () {
  // read the state of the pushbutton value:
int tempUpButtonState = digitalRead(TEMP_UP_PIN);

  if (tempUpButtonState == HIGH){
    if(setTemp >= 104){
      setTemp = 104;
      // delay(400);
    }else {
      setTemp ++;
      // delay(400);
    }
    thermostat = setTemp;
    Serial.print("Setting Temp: ");
    Serial.println(setTemp);
    Serial.print("Current Temp: ");
    Serial.print(getTemp);
    Serial.println(F("°F"));
  }

  int tempDownButtonState = digitalRead(TEMP_DOWN_PIN);

  if (tempDownButtonState == HIGH){
    if(setTemp <= 68){
      setTemp = 68;
      // delay(400);
    }else {
      setTemp --;
      // delay(400);
    }
    thermostat = setTemp;
    Serial.print("Setting Temp: ");
    Serial.println(setTemp);
    Serial.print("Current Temp: ");
    Serial.print(getTemp);
    Serial.println(F("°F"));
  }

  int acButtonState = digitalRead(AIRCON_SWITCH_PIN);

  if (acButtonState == HIGH){
    airConSwitch = !airConSwitch;
    airCon = airConSwitch;
    Serial.println(airConSwitch);
    // delay(400);
  }
  delay(50);
}


void getTempfromDHT () {
  delay(2000);

  // Read temperature as Fahrenheit (isFahrenheit = true)
  float f = dht.readTemperature(true);

 // Check if any reads failed and exit early (to try again).
  if (isnan(f)) {
    Serial.println(F("Failed to read from DHT sensor!"));
    return;
  }

  // Read temperature as Fahrenheit (isFahrenheit = true)
  getTemp = f;
}

float validateTempfromDHT () {
  delay(2000);
  // Read temperature as Fahrenheit (isFahrenheit = true)
  float f = dht.readTemperature(true);

 // Check if any reads failed and exit early (to try again).
  if (isnan(f)) {
    Serial.println(F("Failed to read from DHT sensor!"));
    return 0;
  }

  Serial.print("validated temp: ");
  Serial.println(f);

  return f;

}

void getAirConState () {
  int photoResistorValue1 = analogRead(PHOTORESISTOR_PIN);
  // Serial.println(photoResistorValue1);
    delay(2000);
  int photoResistorValue2 = analogRead(PHOTORESISTOR_PIN);
  // Serial.println(photoResistorValue2);
    
  if (photoResistorValue1 >= airConOnValue){
    if( photoResistorValue2 >= airConOnValue){
    airConState = true;
    // Serial.println("AC Active");
    }
  } else if (photoResistorValue1 < (airConOnValue - 400)){
    if(photoResistorValue2 < (airConOnValue - 400)){
    airConState = false;
    // Serial.println("AC Idle");
    }
  }
}

bool validateAirConState () {
  int photoResistorValue1 = analogRead(PHOTORESISTOR_PIN);
  // Serial.println(photoResistorValue1);
    delay(2000);
  int photoResistorValue2 = analogRead(PHOTORESISTOR_PIN);
  // Serial.println(photoResistorValue2);
    
  if (photoResistorValue1 >= airConOnValue){
    if( photoResistorValue2 >= airConOnValue){
    // Serial.println("AC Active");
    return true;
    }
  } else if (photoResistorValue1 < (airConOnValue - 400)){
    if(photoResistorValue2 < (airConOnValue - 400)){
    // Serial.println("AC Idle");
    return false;
    }
  } else {
    return false;
  }
}


void setLCD () {
  delay(100);
  lcd.clear();

  //Current Temperature Value
  lcd.setCursor(0,0); 
  lcd.print("Temp ");
  lcd.print(getTemp);
  lcd.print((char)223);

  //Set Temperature Value
  lcd.print("Set ");
  lcd.print(setTemp);
  lcd.print((char)223);

  lcd.setCursor(0,1);
  if(airConSwitch) {
    lcd.print("AC: Auto; ");
  } else {
    lcd.print("AC: Off; ");
  }
  if(airConState){
    lcd.print("Active");
  } else {
    lcd.print("Idle");
  }

}